const express = require("express");
const axios = require("axios");
const stringSimilarity = require("string-similarity");
const config = require("../config");
const models = require("../models.js");
const jwt = require("jsonwebtoken");

const router = express.Router();

router.use((req, res, next) => {
  console.log("Time: ", Date.now());
  next();
});

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

router.post("/Vulnerabilities", async (req, res) => {
  let devices = req.body.devices;
  let currVendor = {};
  let cves = [];
  let cveData = [];
  let products = [];

  for (let i = 0; i < devices.length; i++) {
    if (devices[i].product.length < 1) {
      devices.splice(i, 1);
    }
  }

  for (let i = 0; i < devices.length; i++) {
    let product = devices[i].product;
    let vendorWords = devices[i].vendor
      .toLowerCase()
      .replace(/[\.,?!]/g, "")
      .split(" ");
    let vendor = "";
    for (let j = 0; j < vendorWords.length; j++) {
      vendor += vendorWords[j];
      await axios
        .get(`${config.cveURL}/vendors/${vendor}`, {
          headers: { "Content-Type": "application/json" },
          auth: { username: config.cveUser, password: config.cvePassword },
        })
        .then((response) => {
          currVendor = response.data.name;
          products = response.data.products;
        })
        .catch((error) => {
          console.log(error);
        });
      if (currVendor.length > 0) {
        break;
      }
    }
    if (currVendor.length === 0 || products.length === 0) {
      continue;
    } else {
      let match = stringSimilarity.findBestMatch(product, products);
      let index = match.bestMatchIndex;
      await sleep(1000); // bypass ratelimit with small delay
      if (match.bestMatch.rating >= 0.4) {
        await axios
          .get(
            `${config.cveURL}/vendors/${currVendor}/products/${products[index]}/cve`,
            {
              headers: { "Content-Type": "application/json" },
              auth: { username: config.cveUser, password: config.cvePassword },
            }
          )
          .then((response) => {
            for (let k = 0; k < response.data.length; k++) {
              cves.push({ CVE: response.data[k].id, product: product });
            }
          })
          .catch((error) => {
            console.log(error);
          });
      }
    }
  }
  for (let i = 0; i < cves.length; i++) {
    await sleep(100);
    await axios
      .get(`${config.cveURL}/cve/${cves[i].CVE}`, {
        headers: { "Content-Type": "application/json" },
        auth: { username: config.cveUser, password: config.cvePassword },
      })
      .then((response) => {
        cveData.push({ product: cves[i].product, cveData: response.data });
      })
      .catch((error) => {
        console.log(error);
      });
  }
  if (req.headers.cookie) {
    const jwtToken = JSON.parse(
      atob(req.headers.cookie.split("session=")[1].split(";")[0])
    );
    jwt.verify(jwtToken.token, config.secret, async (err, decoded) => {
      if (err) {
        console.log(err);
      } else {
        const scan = await models.Scan.create({
          UserID: decoded.id,
        });
        for (let i = 0; i < cveData.length; i++) {
          const scanData = await models.ScanData.create({
            ScanData: cveData[i],
            ScanID: scan.id,
          });
        }
      }
    });
  }

  if (cveData.length === 0) {
    console.log("204");
    res.status(204).send(cveData);
  } else {
    console.log("200");
    res.send(cveData);
  }
});

module.exports = router;
